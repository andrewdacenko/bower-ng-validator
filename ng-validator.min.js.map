{"version":3,"sources":["ng-validator.min.js","message-bag/message-bag.module.js","validator/validator.module.js","validation-translator/validation-translator.module.js","message-bag/MessageBag.js","validator/validator.js","validation-translator/ValidationTranslator.js","validation-translator/validationTransalatorConfig.js"],"names":["window","angular","undefined","module","MessageBagFactory","MessageBag","bag","ErrorsBag","extend","this","add","bind","has","get","all","first","hasErrors","errors","setErrorsBagPrototype","prototype","field","message","Array","push","prop","hasOwnProperty","copy","factory","ValidatorFactory","ValidationTranslator","makeValidator","data","rules","customMessages","customAttributes","validation","Validation","Validator","extendValidator","rule","fn","studlyCase","fallbackMessages","fails","passes","messages","getMessages","explodeRules","setValidationPrototype","sizeRules","numericRules","implicitRules","customValues","attribute","split","parseRule","isArray","parseArrayRule","parseStringRule","trim","parameters","slice","indexOf","list","parseParameters","parameter","toLowerCase","validate","parsed","value","getValue","addFailure","attributeRules","i","length","getMessage","doReplacements","lowerRule","snakeCase","inlineMessage","getInlineMessage","customKey","join","customMessage","trans","getSizeMessage","key","source","keys","type","getAttributeType","replace","anyFailingRequired","attributes","validateRequired","allFailingRequired","validateAccepted","acceptable","Object","Date","getOwnPropertyNames","validateRequiredIf","validateRequiredWith","validateRequiredWithAll","validateRequiredWithout","validateRequiredWithoutAll","validateIn","validateNotIn","validateInteger","isNaN","validateNumeric","validateBetween","requireParameterCount","size","getSize","count","Error","hasNumeric","hasRule","getStringSize","getRule","getAttribute","getAttributeList","values","getDisplayableValue","replaceBetween","replaceSize","replaceMin","replaceMax","replaceIn","replaceNotIn","replaceRequiredIf","other","replaceRequiredWith","replaceRequiredWithAll","replaceRequiredWithout","replaceRequiredWithoutAll","replaceSame","replaceDifferent","replaceDateFormat","replaceBefore","parse","replaceAfter","upperCaseWords","str","$1","toUpperCase","a","b","r","make","$inject","validationTranslatorLang","validationTranslatorConfig","locales","locale","fallback","localeData","en","accepted","between","numeric","string","array","in","integer","max","min","not_in","regex","required","required_if","required_with","required_with_all","required_without","required_without_all","custom","attribute-name","rule-name","email","colors","F00","0F0","00F"],"mappings":"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","file":"ng-validator.min.js","sourcesContent":[";(function (window, angular, undefined) {\n'use strict';\nangular.module('ngValidator', ['ngValidator.message-bag', 'ngValidator.validation-translator', 'ngValidator.validator']);\n\n(function() {\n    'use strict';\n\n    angular.module('ngValidator.message-bag', []);\n\n})();\n(function() {\n    'use strict';\n\n    angular.module('ngValidator.validator', [\n        'ngValidator.message-bag',\n        'ngValidator.validation-translator'\n    ]);\n\n})();\n(function() {\n    'use strict';\n\n    angular.module('ngValidator.validation-translator', []);\n\n})();\n(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.message-bag', [])\n        .factory('MessageBag', MessageBagFactory);\n\n    function MessageBagFactory() {\n\n        setErrorsBagPrototype();\n\n        return MessageBag;\n\n        function MessageBag() {\n            var bag = new ErrorsBag;\n\n            angular.extend(this, {\n                add: bag.add.bind(bag),\n                has: bag.has.bind(bag),\n                get: bag.get.bind(bag),\n                all: bag.all.bind(bag),\n                first: bag.first.bind(bag),\n                hasErrors: bag.hasErrors.bind(bag)\n            });\n        }\n\n        /**\n         * Create a new ErrorsBag\n         *\n         * @constructor\n         */\n        function ErrorsBag() {\n            this.errors = {};\n        }\n\n        function setErrorsBagPrototype() {\n            /**\n             * Add new error on field validation.\n             *\n             * @param   {string} field\n             * @param   {string} message\n             */\n            ErrorsBag.prototype.add = function add(field, message) {\n                if (!(this.errors[field] instanceof Array)) {\n                    this.errors[field] = [];\n                }\n\n                this.errors[field].push(message);\n            };\n\n            /**\n             * Check if there are any errors.\n             *\n             * @returns {boolean}\n             */\n            ErrorsBag.prototype.hasErrors = function hasErrors() {\n                for (var prop in this.errors) {\n                    /* istanbul ignore else */\n                    if (this.errors.hasOwnProperty(prop)) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            /**\n             * Get all errors.\n             *\n             * @returns {Object}\n             */\n            ErrorsBag.prototype.all = function all() {\n                return angular.copy(this.errors);\n            };\n\n            /**\n             * Check if there are errors at field.\n             *\n             * @param   {string}  field\n             * @returns {boolean}\n             */\n            ErrorsBag.prototype.has = function has(field) {\n                return this.errors[field] ? true : false;\n            };\n\n            /**\n             * Get first error at field.\n             *\n             * @param   {string}  field\n             * @returns {string}\n             */\n            ErrorsBag.prototype.first = function first(field) {\n                if (this.has(field)) {\n                    return this.errors[field][0];\n                }\n\n                return '';\n            };\n\n            /**\n             * Get all the field errors.\n             *\n             * @param   {string}  field\n             * @returns {Object}\n             */\n            ErrorsBag.prototype.get = function get(field) {\n                if (this.has(field)) {\n                    return this.errors[field];\n                }\n\n                return [];\n            };\n        }\n    }\n\n})();\n\n(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.validator')\n        .factory('Validator', ValidatorFactory);\n\n    /*@ngInject*/\n    function ValidatorFactory(MessageBag, ValidationTranslator) {\n\n        var factory = {\n            make: makeValidator,\n            extend: extendValidator\n        };\n\n        setValidationPrototype();\n\n        return factory;\n\n        /**\n         * Create new Validator.\n         *\n         * @param   {Object} data\n         * @param   {Object} rules\n         * @param   {Object} customMessages\n         * @param   {Object} customAttributes\n         * @returns {Validator}\n         */\n        function makeValidator(data, rules, customMessages, customAttributes) {\n            var validation = new Validation(data, rules, customMessages, customAttributes);\n\n            return new Validator(validation);\n        }\n\n        /**\n         * Extend validation set of rules.\n         *\n         * @param   {string}   rule\n         * @param   {Function} fn\n         * @param   {string}   message\n         */\n        function extendValidator(rule, fn, message) {\n            rule = studlyCase(rule);\n            Validation.prototype['validate' + rule] = fn;\n            Validation.prototype.fallbackMessages[rule] = message || '';\n        }\n\n        /**\n         * Create instance of Validation\n         *\n         * @param   {Validation} validation\n         * @constructor\n         */\n        function Validator(validation) {\n            angular.extend(this, {\n                fails: validation.fails.bind(validation),\n                passes: validation.passes.bind(validation),\n                messages: validation.getMessages.bind(validation),\n                errors: validation.getMessages.bind(validation)\n            });\n        }\n\n        /**\n         * Create new Validation instance.\n         *\n         * @param {Object} data\n         * @param {Object} rules\n         * @param {Object} customMessages\n         * @param {Object} customAttributes\n         * @constructor\n         */\n        function Validation(data, rules, customMessages, customAttributes) {\n            this.data = data;\n            this.rules = this.explodeRules(rules);\n            this.customMessages = customMessages || {};\n            this.customAttributes = customAttributes || {};\n        }\n\n        function setValidationPrototype() {\n\n            /**\n             * The size related validation rules.\n             *\n             * @attribute {Array}\n             */\n            Validation.prototype.sizeRules = ['Size', 'Between', 'Min', 'Max'];\n\n            /**\n             * The numeric related validation rules.\n             *\n             * @attribute {Array}\n             */\n            Validation.prototype.numericRules = ['Numeric', 'Integer'];\n\n            /**\n             * The validation rules that imply the attribute is required.\n             *\n             * @attribute {Array}\n             */\n            Validation.prototype.implicitRules = ['Required', 'RequiredWith', 'RequiredWithAll', 'RequiredWithout', 'RequiredWithoutAll', 'RequiredIf', 'Accepted'];\n\n            /**\n             * Fallback messages\n             *\n             * @attribute {Object}\n             */\n            Validation.prototype.fallbackMessages = {};\n\n            /**\n             * The array of custom attribute names.\n             *\n             * @attribute {Object}\n             */\n            Validation.prototype.customAttributes = {};\n\n            /**\n             * The array of custom displayable values.\n             *\n             * @attribute {Object}\n             */\n            Validation.prototype.customValues = {};\n\n            /**\n             * Explode the rules into an array of rules.\n             *\n             * @param   {Object} rules\n             *\n             * @returns {Object}\n             */\n            Validation.prototype.explodeRules = function(rules) {\n                for (var attribute in rules) {\n                    if (rules.hasOwnProperty(attribute)) {\n                        rules[attribute] = (typeof rules[attribute] === 'string')\n                            ? rules[attribute].split('|')\n                            : rules[attribute];\n                    }\n                }\n\n                return rules;\n            };\n\n            /**\n             * Extract the rule name and parameters from a rule.\n             *\n             * @param   {Array|String} rules\n             *\n             * @returns {Object}\n             */\n            Validation.prototype.parseRule = function(rules) {\n                if (Array.isArray(rules)) {\n                    return this.parseArrayRule(rules);\n                }\n\n                return this.parseStringRule(rules);\n            };\n\n            /**\n             * Parse an array based rule.\n             *\n             * @param   {Array} rules\n             *\n             * @returns {Object}\n             */\n            Validation.prototype.parseArrayRule = function(rules) {\n                return {\n                    rule: studlyCase(rules[0].trim()),\n                    parameters: rules.slice(1)\n                };\n            };\n\n            /**\n             * Parse a string based rule.\n             *\n             * @param   {string} rules\n             *\n             * @returns {Array}\n             */\n            Validation.prototype.parseStringRule = function(rules) {\n                var parameters = [];\n\n                // The format for specifying validation rules and parameters\n                // follows an easy {rule}:{parameters} formatting convention.\n                if (rules.indexOf(':') !== -1) {\n                    var list = rules.split(':');\n                    rules = list[0];\n                    parameters = this.parseParameters(rules, list[1]);\n                }\n\n                return {\n                    rule: studlyCase(rules.trim()),\n                    parameters: parameters\n                };\n            };\n\n            /**\n             * Parse a parameter list.\n             *\n             * @param   {string} rule\n             * @param   {string} parameter\n             *\n             * @returns {Array}\n             */\n            Validation.prototype.parseParameters = function(rule, parameter) {\n                if (rule.toLowerCase() == 'regex') return [parameter];\n                return parameter.split(',');\n            };\n\n            /**\n             * Validate a given attribute against a rule.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             */\n            Validation.prototype.validate = function(attribute, rule) {\n                var parsed = this.parseRule(rule);\n\n                if (parsed.rule === '') return;\n\n                var value = this.getValue(attribute);\n\n                if (!this['validate' + parsed.rule](attribute, value, parsed.parameters)) {\n                    this.addFailure(attribute, parsed.rule, parsed.parameters);\n                }\n            };\n\n            /**\n             * Determine if the data passes the validation rules.\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.passes = function() {\n                return !this.fails();\n            };\n\n            /**\n             * Determine if the data fails the validation rules.\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.fails = function() {\n                this.messages = new MessageBag;\n\n                for (var attribute in this.rules) {\n                    var attributeRules = this.rules[attribute];\n\n                    for (var i = 0; i < attributeRules.length; i++) {\n                        this.validate(attribute, attributeRules[i]);\n                    }\n                }\n\n                return this.messages.hasErrors();\n            };\n\n            Validation.prototype.getMessages = function() {\n                return angular.copy(this.messages);\n            };\n\n            /**\n             * Add a failed rule and error message to the collection.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             */\n            Validation.prototype.addFailure = function(attribute, rule, parameters) {\n                var message = this.getMessage(attribute, rule);\n\n                message = this.doReplacements(message, attribute, rule, parameters);\n\n                this.messages.add(attribute, message);\n            };\n\n            /**\n             * Get the validation message for an attribute and rule.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getMessage = function(attribute, rule) {\n                var lowerRule = snakeCase(rule);\n\n                var inlineMessage = this.getInlineMessage(attribute, lowerRule);\n\n                // First we will retrieve the custom message for the\n                // validation rule if one exists. If a custom validation\n                // message is being used we'll return the custom message,\n                // otherwise we'll keep searching for a valid message.\n                if (inlineMessage) {\n                    return inlineMessage;\n                }\n\n                var customKey = [\"custom.\", attribute, '.', lowerRule].join('');\n\n                var customMessage = ValidationTranslator.trans(customKey);\n\n                // Than we check for a custom defined validation message for\n                // the attribute and rule. This allows the developer to\n                // specify specific messages for only some attributes and\n                // rules that need to get specially formed.\n                if (customMessage !== customKey) {\n                    return customMessage;\n                }\n\n                // If the rule being validated is a \"size\" rule, we will need\n                // to gather the specific error message for the type of\n                // attribute being validated such as a number, file or string\n                // which all have different message types.\n                else if (this.sizeRules.indexOf(rule) !== -1) {\n                    return this.getSizeMessage(attribute, rule);\n                }\n\n                // Than, if no developer specified messages have been set, and\n                // no other special messages apply for this rule, we will just\n                // pull the default\n                var key = lowerRule;\n                var value = ValidationTranslator.trans(key);\n\n                if (key !== value) {\n                    return value;\n                }\n\n                return this.getInlineMessage(attribute, lowerRule, this.fallbackMessages) || key;\n            };\n\n            /**\n             * Get the inline message for a rule if it exists.\n             *\n             * @param   {string} attribute\n             * @param   {string} lowerRule\n             * @param   {Array}  source\n             *\n             * @return {string|undefined}\n             */\n            Validation.prototype.getInlineMessage = function(attribute, lowerRule, source) {\n                var messages = source || this.customMessages;\n                var keys = [attribute + '.' + lowerRule, studlyCase(lowerRule)];\n\n                // First we will check for a custom message for an attribute\n                // specific rule message for the attributes, then we will\n                // check for a general custom message that is not attribute\n                // specific. If we find either we'll return it.\n                for (var key in keys) {\n                    if (messages[keys[key]] !== undefined) return messages[keys[key]];\n                }\n            };\n\n            /**\n             * Get the proper error message for an attribute and size rule.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getSizeMessage = function(attribute, rule) {\n                var lowerRule = snakeCase(rule);\n                // There are three different types of size validations. The\n                // attribute may be either a number, file, or string so we\n                // will check a few things to know which type of value it is\n                // and return the correct line for that type.\n                var type = this.getAttributeType(attribute);\n\n                var key = [lowerRule, '.', type].join('');\n\n                return ValidationTranslator.trans(key);\n            };\n\n            /**\n             * Replace all error message place-holders with actual values.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.doReplacements = function(message, attribute, rule, parameters) {\n                message = replace(message, {\n                    attribute: attribute\n                });\n\n                if (this['replace' + rule] !== undefined) {\n                    message = this['replace' + rule](message, attribute, rule, parameters);\n                }\n\n                return message;\n            };\n\n            /**\n             * Get the value of a given attribute.\n             *\n             * @param   {string} attribute\n             *\n             * @returns {*}\n             */\n            Validation.prototype.getValue = function(attribute) {\n                return this.data[attribute];\n            };\n\n            /**\n             * Determine if any of the given attributes fail the required test.\n             *\n             * @param   {array} attributes\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.anyFailingRequired = function(attributes) {\n                for (var key in attributes) {\n                    if (!this.validateRequired(attributes[key], this.getValue(attributes[key]))) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            /**\n             * Determine if all of the given attributes fail the required test.\n             *\n             * @param   {Array} attributes\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.allFailingRequired = function(attributes) {\n                for (var key in attributes) {\n                    if (this.validateRequired(attributes[key], this.getValue(attributes[key]))) {\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute was \"accepted\".\n             *\n             * This validation rule implies the attribute is \"required\".\n             *\n             * @param   {string}  attribute\n             * @param   {*}       value\n             *\n             * @return {boolean}\n             */\n            Validation.prototype.validateAccepted = function(attribute, value) {\n                var acceptable = ['yes', 'on', '1', 1, true, 'true'];\n\n                return (this.validateRequired(attribute, value) && acceptable.indexOf(value) !== -1);\n            };\n\n            /**\n             * Validate that a required attribute exists.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @return {boolean}\n             */\n            Validation.prototype.validateRequired = function(attribute, value) {\n                if (value === null || value === undefined) {\n                    return false\n                } else if (typeof value === 'string') {\n                    if (value.trim() === '') {\n                        return false;\n                    }\n                } else if (value instanceof Array) {\n                    if (value.length < 1) {\n                        return false\n                    }\n                } else if (value instanceof Object && !(value instanceof Date)) {\n                    if (Object.getOwnPropertyNames(value).length === 0) {\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when other attribute has\n             * certain value.\n             *\n             * @param {string} attribute\n             * @param {*}      value\n             * @param {Array}  parameters\n             *\n             * @return {boolean}\n             */\n            Validation.prototype.validateRequiredIf = function(attribute, value, parameters) {\n                if (this.getValue(parameters[0]) == parameters[1]) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when any other attribute\n             * exists.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {Array}  parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWith = function(attribute, value, parameters) {\n                if (!this.allFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when all other attributes\n             * exists.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {*}      parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWithAll = function(attribute, value, parameters) {\n                if (!this.anyFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when another attribute does\n             * not.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {*}      parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWithout = function(attribute, value, parameters) {\n                if (this.anyFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when all other attributes do\n             * not.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {*}      parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWithoutAll = function(attribute, value, parameters) {\n                if (this.allFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate an attribute is contained within a list of values.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {Array}  parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateIn = function(attribute, value, parameters) {\n                return parameters.indexOf('' + value) !== -1;\n            };\n\n            /**\n             * Validate an attribute is not contained within a list of values.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {Array}  parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateNotIn = function(attribute, value, parameters) {\n                return !this.validateIn(attribute, value, parameters);\n            };\n\n            /**\n             * Validate that an attribute is an integer.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateInteger = function(attribute, value) {\n                return !isNaN(value) && value === (value | 0);\n            };\n\n            /**\n             * Validate that an attribute is numeric.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateNumeric = function(attribute, value) {\n                return !isNaN(value);\n            };\n\n            /**\n             * Validate the size of an attribute is between a set of values.\n             *\n             * @param   {string}              attribute\n             * @param   {string|number|Array} value\n             * @param   {Array}               parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateBetween = function(attribute, value, parameters) {\n                this.requireParameterCount(2, parameters, 'between');\n\n                var size = this.getSize(attribute, value);\n\n                return size >= parameters[0] && size <= parameters[1];\n            };\n\n            /**\n             * Require a certain number of parameters to be present.\n             *\n             * @param   {Integer} count\n             * @param   {Array}   parameters\n             * @param   {string}  rule\n             *\n             * @returns {undefined}\n             *\n             * @throws {Error}\n             */\n            Validation.prototype.requireParameterCount = function(count, parameters, rule) {\n                if (parameters.length < count) {\n                    throw new Error(\"Validation rule \" + rule + \" requires at least \" + count + \" parameters.\");\n                }\n            };\n\n            /**\n             * Get the size of an attribute.\n             *\n             * @param   {string}              attribute\n             * @param   {string|number|Array} value\n             *\n             * @returns {number}\n             */\n            Validation.prototype.getSize = function(attribute, value) {\n                var hasNumeric = this.hasRule(attribute, this.numericRules);\n\n                // This method will determine if the attribute is a number,\n                // string, or array and return the proper size accordingly. If\n                // it is a number, then number itself is the size. If it is an\n                // array, we take length, and for a string the entire length\n                // of the string will be considered the attribute size.\n                if (!isNaN(value) && hasNumeric) {\n                    return this.data[attribute];\n                } else if (Array.isArray(value)) {\n                    return value.length;\n                }\n\n                return this.getStringSize(value);\n            };\n\n            /**\n             * Get the size of a string.\n             *\n             * @param   {string} value\n             *\n             * @returns {number}\n             */\n            Validation.prototype.getStringSize = function(value) {\n                if (value) {\n                    return ('' + value).trim().length;\n                }\n\n                return 0;\n            };\n\n            /**\n             * Determine if the given attribute has a rule in the given set.\n             *\n             * @param   {string}        attribute\n             * @param   {string|Object} rules\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.hasRule = function(attribute, rules) {\n                return !!this.getRule(attribute, rules);\n            };\n\n            /**\n             * Get a rule and its parameters for a given attribute.\n             *\n             * @param   {string}        attribute\n             * @param   {string|Object} rules\n             *\n             * @returns {Object|undefined}\n             */\n            Validation.prototype.getRule = function(attribute, rules) {\n                if (!this.rules[attribute]) {\n                    return;\n                }\n\n                for (var rule in this.rules) {\n                    var parsed = this.parseRule(this.rules[rule]);\n\n                    if (rules.indexOf(parsed.rule) !== -1) {\n                        return parsed;\n                    }\n                }\n            };\n\n            /**\n             * Get the displayable name of the attribute.\n             *\n             * @param   {string} attribute\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getAttribute = function(attribute) {\n                // The developer may dynamically specify the array of custom\n                // attributes on this Validation instance. If the attribute\n                // exists in this array it takes precedence over all other\n                // ways we can pull attributes.\n                if (this.customAttributes[attribute]) {\n                    return this.customAttributes[attribute];\n                }\n\n                var key = 'attributes.' + attribute;\n                // We allow for the developer to specify language messages for\n                // each of the attributes allowing for more displayable\n                // counterparts of each of the attributes. This provides the\n                // ability for simple formats.\n\n                var message = ValidationTranslator.trans(key);\n\n                if (message !== key) {\n                    return message;\n                }\n\n                // If no language message has been specified for the attribute\n                // all of the underscores are removed from the attribute name\n                // and that will be used as default versions of the\n                // attribute`s displayable names.\n                return snakeCase(attribute).replace(/_/g, ' ');\n            };\n\n            /**\n             * Get the data type of the given attribute.\n             *\n             * @param   {string} attribute\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getAttributeType = function(attribute) {\n                if (this.hasRule(attribute, this.numericRules)) {\n                    return 'numeric';\n                } else if (this.hasRule(attribute, 'Array')) {\n                    return 'array';\n                }\n\n                return 'string';\n            };\n\n            /**\n             * Transform an array of attributes to their displayable form.\n             *\n             * @param   {Array} values\n             *\n             * @returns {Array}\n             */\n            Validation.prototype.getAttributeList = function(values) {\n                var attributes = [];\n\n                // For each attribute in the list we will simply get its\n                // displayable form as this is convenient when replacing lists\n                // of parameters like some of the replacement functions do\n                // when formatting out the validation message.\n                for (var i = 0; i < values.length; i++) {\n                    attributes.push(this.getAttribute(values[i]));\n                }\n\n                return attributes;\n            };\n\n            /**\n             * Get the displayable name of the value.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getDisplayableValue = function(attribute, value) {\n                if (this.customValues[attribute] && this.customValues[attribute][value]) {\n                    return this.customValues[attribute][value];\n                }\n\n                var key = 'values.' + attribute + '.' + value;\n\n                var message = ValidationTranslator.trans(key);\n\n                if (message !== key) {\n                    return message;\n                }\n\n                return value;\n            };\n\n            /**\n             * Replace all place-holders for the between rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceBetween = function(message, attribute, rule, parameters) {\n                return message.replace(':min', parameters[0]).replace(':max', parameters[1]);\n            };\n\n            /**\n             * Replace all place-holders for the size rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceSize = function(message, attribute, rule, parameters) {\n                return message.replace(':size', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the min rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceMin = function(message, attribute, rule, parameters) {\n                return message.replace(':min', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the max rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceMax = function(message, attribute, rule, parameters) {\n                return message.replace(':max', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the in rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceIn = function(message, attribute, rule, parameters) {\n                for (var i = 0; i < parameters.length; i++) {\n                    parameters[i] = this.getDisplayableValue(attribute, parameters[i]);\n                }\n\n                return message.replace(':values', parameters.join(', '));\n            };\n\n            /**\n             * Replace all place-holders for the not_in rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceNotIn = function(message, attribute, rule, parameters) {\n                return this.replaceIn(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_if rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredIf = function(message, attribute, rule, parameters) {\n                parameters[1] = this.getDisplayableValue(parameters[0], this.getValue(parameters[0]));\n                parameters[0] = this.getAttribute(parameters[0]);\n\n                return replace(message, {other: parameters[0], value: parameters[1]});\n            };\n\n            /**\n             * Replace all place-holders for the required_with rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWith = function(message, attribute, rule, parameters) {\n                parameters = this.getAttributeList(parameters);\n                return message.replace(':values', parameters.join(' / '));\n            };\n\n            /**\n             * Replace all place-holders for the required_with_all rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWithAll = function(message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_without rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWithout = function(message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_without_all rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWithoutAll = function(message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the same rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceSame = function(message, attribute, rule, parameters) {\n                return message.replace(':other', this.getAttribute(parameters[0]));\n            };\n\n            /**\n             * Replace all place-holders for the different rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceDifferent = function(message, attribute, rule, parameters) {\n                return this.replaceSame(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the date_format rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceDateFormat = function(message, attribute, rule, parameters) {\n                return message.replace(':format', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the before rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceBefore = function(message, attribute, rule, parameters) {\n                if (!Date.parse(parameters[0])) {\n                    return message.replace(':date', this.getAttribute(parameters[0]));\n                }\n                return message.replace(':date', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the after rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceAfter = function(message, attribute, rule, parameters) {\n                return this.replaceBefore(message, attribute, rule, parameters);\n            };\n        }\n\n        /**\n         * Helpers goes next\n         */\n\n        /**\n         * Convert each word`s first letter to upper case.\n         *\n         * @param {String} str\n         *\n         * @return {String}\n         */\n        function upperCaseWords(str) {\n            return (str + '').replace(/^([a-z])|\\s+([a-z])/g, function($1) {\n                return $1.toUpperCase();\n            });\n        }\n\n        /**\n         * Convert text into studly case.\n         *\n         * @param {String} str\n         *\n         * @return {String}\n         */\n        function studlyCase(str) {\n            str = upperCaseWords((str + '').replace(/[-_]/g, ' '));\n            return str.replace(/[\\s]/g, '');\n        }\n\n        /**\n         * Convert text into snake case.\n         *\n         * @param {String} str\n         *\n         * @return {String}\n         */\n        function snakeCase(str) {\n            return (str + '').replace(/(.)([A-Z])/g, '$1_$2').toLowerCase();\n        }\n\n        /**\n         * Replace placeholders with object keys\n         *\n         * @example\n         * // returns 'Dear Andrew'\n         * var str = \":greet :name\"\n         * var greet = {greet: 'Dear', name: 'Andrew'};\n         * replace(str, greet);\n         *\n         * @param {String} str  String containing placeholders\n         * @param {Object} data Object with corresponding keys\n         *\n         * @return {String} Final string with replaced placeholders\n         */\n        function replace(str, data) {\n            return (str + '').replace(/:([A-z]*)/g,\n                function(a, b) {\n                    var r = data[b];\n                    return typeof r === 'string' || typeof r === 'number' ? r : a;\n                }\n            );\n        }\n    }\n\n})();\n\n(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.validation-translator')\n        .value('validationTranslatorLang', {\n            locale: 'en',\n            fallback: 'en'\n        })\n        .factory('ValidationTranslator', ValidationTranslator);\n\n    /*@ngInject*/\n    function ValidationTranslator(validationTranslatorLang, validationTranslatorConfig) {\n        return {\n            trans: trans\n        };\n\n        function trans(key) {\n            var message = null;\n\n            // Here we will get the locale that should be used for the\n            // language. If one was not passed, we will use the default\n            // locale. Then, we can get the  message and return.\n            var locales = [\n                validationTranslatorLang.locale,\n                validationTranslatorLang.fallback\n            ];\n\n            for (var i = 0; i < locales.length; i++) {\n                message = getMessage(locales[i], key);\n\n                if (message) break;\n            }\n\n            // If the message doesn't exist, we will return back the key\n            // which was requested as that will be quick to spot in the UI\n            // if language keys are wrong or missing from the translator's\n            // language config. Otherwise we can return the message.\n            if (!message) return key;\n\n            return message;\n        }\n\n        function getMessage(locale, key) {\n            var message;\n\n            var localeData = validationTranslatorConfig[locale];\n\n            if (localeData) {\n                var data = localeData;\n                var keys = key.split('.');\n\n                for (var i = 0; i < keys.length; i++) {\n                    if (data[keys[i]]) {\n                        data = data[keys[i]];\n                    } else {\n                        return;\n                    }\n                }\n\n                message = data;\n            }\n\n            return message;\n        }\n    }\n\n})();\n\n(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.validation-translator')\n        .value('validationTranslatorConfig', {\n            \"en\": {\n                \"accepted\": \"The :attribute must be accepted.\",\n                \"between\": {\n                    \"numeric\": \"The :attribute must be between :min and :max.\",\n                    \"string\": \"The :attribute must be between :min and :max characters.\",\n                    \"array\": \"The :attribute must have between :min and :max items.\"\n                },\n                \"in\": \"The selected :attribute is invalid.\",\n                \"integer\": \"The :attribute must be an integer.\",\n                \"max\": {\n                    \"numeric\": \"The :attribute may not be greater than :max.\",\n                    \"string\": \"The :attribute may not be greater than :max characters.\",\n                    \"array\": \"The :attribute may not have more than :max items.\"\n                },\n                \"min\": {\n                    \"numeric\": \"The :attribute must be at least :min.\",\n                    \"string\": \"The :attribute must be at least :min characters.\",\n                    \"array\": \"The :attribute must have at least :min items.\"\n                },\n                \"not_in\": \"The selected :attribute is invalid.\",\n                \"numeric\": \"The :attribute must be a number.\",\n                \"regex\": \"The :attribute format is invalid.\",\n                \"required\": \"The :attribute field is required.\",\n                \"required_if\": \"The :attribute field is required when :other is :value.\",\n                \"required_with\": \"The :attribute field is required when :values is present.\",\n                \"required_with_all\": \"The :attribute field is required when :values is present.\",\n                \"required_without\": \"The :attribute field is required when :values is not present.\",\n                \"required_without_all\": \"The :attribute field is required when none of :values are present.\",\n\n                // Developers can set custom validation messages on some\n                // attributes validation rules\n                \"custom\": {\n                    \"attribute-name\": {\n                        \"rule-name\": \"custom-message\"\n                    }\n                },\n\n                // Developers can set displayable value for some attributes\n                \"attributes\": {\n                    \"email\": \"Email address\"\n                },\n\n                // As an example just set displayable value for colors attribute\n                // and its values\n                \"values\": {\n                    \"colors\": {\n                        \"F00\": \"Red\",\n                        \"0F0\": \"Green\",\n                        \"00F\": \"Blue\"\n                    }\n                }\n            }\n        });\n})();\n})(window, angular);","(function() {\n    'use strict';\n\n    angular.module('ngValidator.message-bag', []);\n\n})();","(function() {\n    'use strict';\n\n    angular.module('ngValidator.validator', [\n        'ngValidator.message-bag',\n        'ngValidator.validation-translator'\n    ]);\n\n})();","(function() {\n    'use strict';\n\n    angular.module('ngValidator.validation-translator', []);\n\n})();","(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.message-bag', [])\n        .factory('MessageBag', MessageBagFactory);\n\n    function MessageBagFactory() {\n\n        setErrorsBagPrototype();\n\n        return MessageBag;\n\n        function MessageBag() {\n            var bag = new ErrorsBag;\n\n            angular.extend(this, {\n                add: bag.add.bind(bag),\n                has: bag.has.bind(bag),\n                get: bag.get.bind(bag),\n                all: bag.all.bind(bag),\n                first: bag.first.bind(bag),\n                hasErrors: bag.hasErrors.bind(bag)\n            });\n        }\n\n        /**\n         * Create a new ErrorsBag\n         *\n         * @constructor\n         */\n        function ErrorsBag() {\n            this.errors = {};\n        }\n\n        function setErrorsBagPrototype() {\n            /**\n             * Add new error on field validation.\n             *\n             * @param   {string} field\n             * @param   {string} message\n             */\n            ErrorsBag.prototype.add = function add(field, message) {\n                if (!(this.errors[field] instanceof Array)) {\n                    this.errors[field] = [];\n                }\n\n                this.errors[field].push(message);\n            };\n\n            /**\n             * Check if there are any errors.\n             *\n             * @returns {boolean}\n             */\n            ErrorsBag.prototype.hasErrors = function hasErrors() {\n                for (var prop in this.errors) {\n                    /* istanbul ignore else */\n                    if (this.errors.hasOwnProperty(prop)) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            /**\n             * Get all errors.\n             *\n             * @returns {Object}\n             */\n            ErrorsBag.prototype.all = function all() {\n                return angular.copy(this.errors);\n            };\n\n            /**\n             * Check if there are errors at field.\n             *\n             * @param   {string}  field\n             * @returns {boolean}\n             */\n            ErrorsBag.prototype.has = function has(field) {\n                return this.errors[field] ? true : false;\n            };\n\n            /**\n             * Get first error at field.\n             *\n             * @param   {string}  field\n             * @returns {string}\n             */\n            ErrorsBag.prototype.first = function first(field) {\n                if (this.has(field)) {\n                    return this.errors[field][0];\n                }\n\n                return '';\n            };\n\n            /**\n             * Get all the field errors.\n             *\n             * @param   {string}  field\n             * @returns {Object}\n             */\n            ErrorsBag.prototype.get = function get(field) {\n                if (this.has(field)) {\n                    return this.errors[field];\n                }\n\n                return [];\n            };\n        }\n    }\n\n})();\n","(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.validator')\n        .factory('Validator', ValidatorFactory);\n\n    /*@ngInject*/\n    function ValidatorFactory(MessageBag, ValidationTranslator) {\n\n        var factory = {\n            make: makeValidator,\n            extend: extendValidator\n        };\n\n        setValidationPrototype();\n\n        return factory;\n\n        /**\n         * Create new Validator.\n         *\n         * @param   {Object} data\n         * @param   {Object} rules\n         * @param   {Object} customMessages\n         * @param   {Object} customAttributes\n         * @returns {Validator}\n         */\n        function makeValidator(data, rules, customMessages, customAttributes) {\n            var validation = new Validation(data, rules, customMessages, customAttributes);\n\n            return new Validator(validation);\n        }\n\n        /**\n         * Extend validation set of rules.\n         *\n         * @param   {string}   rule\n         * @param   {Function} fn\n         * @param   {string}   message\n         */\n        function extendValidator(rule, fn, message) {\n            rule = studlyCase(rule);\n            Validation.prototype['validate' + rule] = fn;\n            Validation.prototype.fallbackMessages[rule] = message || '';\n        }\n\n        /**\n         * Create instance of Validation\n         *\n         * @param   {Validation} validation\n         * @constructor\n         */\n        function Validator(validation) {\n            angular.extend(this, {\n                fails: validation.fails.bind(validation),\n                passes: validation.passes.bind(validation),\n                messages: validation.getMessages.bind(validation),\n                errors: validation.getMessages.bind(validation)\n            });\n        }\n\n        /**\n         * Create new Validation instance.\n         *\n         * @param {Object} data\n         * @param {Object} rules\n         * @param {Object} customMessages\n         * @param {Object} customAttributes\n         * @constructor\n         */\n        function Validation(data, rules, customMessages, customAttributes) {\n            this.data = data;\n            this.rules = this.explodeRules(rules);\n            this.customMessages = customMessages || {};\n            this.customAttributes = customAttributes || {};\n        }\n\n        function setValidationPrototype() {\n\n            /**\n             * The size related validation rules.\n             *\n             * @attribute {Array}\n             */\n            Validation.prototype.sizeRules = ['Size', 'Between', 'Min', 'Max'];\n\n            /**\n             * The numeric related validation rules.\n             *\n             * @attribute {Array}\n             */\n            Validation.prototype.numericRules = ['Numeric', 'Integer'];\n\n            /**\n             * The validation rules that imply the attribute is required.\n             *\n             * @attribute {Array}\n             */\n            Validation.prototype.implicitRules = ['Required', 'RequiredWith', 'RequiredWithAll', 'RequiredWithout', 'RequiredWithoutAll', 'RequiredIf', 'Accepted'];\n\n            /**\n             * Fallback messages\n             *\n             * @attribute {Object}\n             */\n            Validation.prototype.fallbackMessages = {};\n\n            /**\n             * The array of custom attribute names.\n             *\n             * @attribute {Object}\n             */\n            Validation.prototype.customAttributes = {};\n\n            /**\n             * The array of custom displayable values.\n             *\n             * @attribute {Object}\n             */\n            Validation.prototype.customValues = {};\n\n            /**\n             * Explode the rules into an array of rules.\n             *\n             * @param   {Object} rules\n             *\n             * @returns {Object}\n             */\n            Validation.prototype.explodeRules = function(rules) {\n                for (var attribute in rules) {\n                    if (rules.hasOwnProperty(attribute)) {\n                        rules[attribute] = (typeof rules[attribute] === 'string')\n                            ? rules[attribute].split('|')\n                            : rules[attribute];\n                    }\n                }\n\n                return rules;\n            };\n\n            /**\n             * Extract the rule name and parameters from a rule.\n             *\n             * @param   {Array|String} rules\n             *\n             * @returns {Object}\n             */\n            Validation.prototype.parseRule = function(rules) {\n                if (Array.isArray(rules)) {\n                    return this.parseArrayRule(rules);\n                }\n\n                return this.parseStringRule(rules);\n            };\n\n            /**\n             * Parse an array based rule.\n             *\n             * @param   {Array} rules\n             *\n             * @returns {Object}\n             */\n            Validation.prototype.parseArrayRule = function(rules) {\n                return {\n                    rule: studlyCase(rules[0].trim()),\n                    parameters: rules.slice(1)\n                };\n            };\n\n            /**\n             * Parse a string based rule.\n             *\n             * @param   {string} rules\n             *\n             * @returns {Array}\n             */\n            Validation.prototype.parseStringRule = function(rules) {\n                var parameters = [];\n\n                // The format for specifying validation rules and parameters\n                // follows an easy {rule}:{parameters} formatting convention.\n                if (rules.indexOf(':') !== -1) {\n                    var list = rules.split(':');\n                    rules = list[0];\n                    parameters = this.parseParameters(rules, list[1]);\n                }\n\n                return {\n                    rule: studlyCase(rules.trim()),\n                    parameters: parameters\n                };\n            };\n\n            /**\n             * Parse a parameter list.\n             *\n             * @param   {string} rule\n             * @param   {string} parameter\n             *\n             * @returns {Array}\n             */\n            Validation.prototype.parseParameters = function(rule, parameter) {\n                if (rule.toLowerCase() == 'regex') return [parameter];\n                return parameter.split(',');\n            };\n\n            /**\n             * Validate a given attribute against a rule.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             */\n            Validation.prototype.validate = function(attribute, rule) {\n                var parsed = this.parseRule(rule);\n\n                if (parsed.rule === '') return;\n\n                var value = this.getValue(attribute);\n\n                if (!this['validate' + parsed.rule](attribute, value, parsed.parameters)) {\n                    this.addFailure(attribute, parsed.rule, parsed.parameters);\n                }\n            };\n\n            /**\n             * Determine if the data passes the validation rules.\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.passes = function() {\n                return !this.fails();\n            };\n\n            /**\n             * Determine if the data fails the validation rules.\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.fails = function() {\n                this.messages = new MessageBag;\n\n                for (var attribute in this.rules) {\n                    var attributeRules = this.rules[attribute];\n\n                    for (var i = 0; i < attributeRules.length; i++) {\n                        this.validate(attribute, attributeRules[i]);\n                    }\n                }\n\n                return this.messages.hasErrors();\n            };\n\n            Validation.prototype.getMessages = function() {\n                return angular.copy(this.messages);\n            };\n\n            /**\n             * Add a failed rule and error message to the collection.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             */\n            Validation.prototype.addFailure = function(attribute, rule, parameters) {\n                var message = this.getMessage(attribute, rule);\n\n                message = this.doReplacements(message, attribute, rule, parameters);\n\n                this.messages.add(attribute, message);\n            };\n\n            /**\n             * Get the validation message for an attribute and rule.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getMessage = function(attribute, rule) {\n                var lowerRule = snakeCase(rule);\n\n                var inlineMessage = this.getInlineMessage(attribute, lowerRule);\n\n                // First we will retrieve the custom message for the\n                // validation rule if one exists. If a custom validation\n                // message is being used we'll return the custom message,\n                // otherwise we'll keep searching for a valid message.\n                if (inlineMessage) {\n                    return inlineMessage;\n                }\n\n                var customKey = [\"custom.\", attribute, '.', lowerRule].join('');\n\n                var customMessage = ValidationTranslator.trans(customKey);\n\n                // Than we check for a custom defined validation message for\n                // the attribute and rule. This allows the developer to\n                // specify specific messages for only some attributes and\n                // rules that need to get specially formed.\n                if (customMessage !== customKey) {\n                    return customMessage;\n                }\n\n                // If the rule being validated is a \"size\" rule, we will need\n                // to gather the specific error message for the type of\n                // attribute being validated such as a number, file or string\n                // which all have different message types.\n                else if (this.sizeRules.indexOf(rule) !== -1) {\n                    return this.getSizeMessage(attribute, rule);\n                }\n\n                // Than, if no developer specified messages have been set, and\n                // no other special messages apply for this rule, we will just\n                // pull the default\n                var key = lowerRule;\n                var value = ValidationTranslator.trans(key);\n\n                if (key !== value) {\n                    return value;\n                }\n\n                return this.getInlineMessage(attribute, lowerRule, this.fallbackMessages) || key;\n            };\n\n            /**\n             * Get the inline message for a rule if it exists.\n             *\n             * @param   {string} attribute\n             * @param   {string} lowerRule\n             * @param   {Array}  source\n             *\n             * @return {string|undefined}\n             */\n            Validation.prototype.getInlineMessage = function(attribute, lowerRule, source) {\n                var messages = source || this.customMessages;\n                var keys = [attribute + '.' + lowerRule, studlyCase(lowerRule)];\n\n                // First we will check for a custom message for an attribute\n                // specific rule message for the attributes, then we will\n                // check for a general custom message that is not attribute\n                // specific. If we find either we'll return it.\n                for (var key in keys) {\n                    if (messages[keys[key]] !== undefined) return messages[keys[key]];\n                }\n            };\n\n            /**\n             * Get the proper error message for an attribute and size rule.\n             *\n             * @param   {string} attribute\n             * @param   {string} rule\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getSizeMessage = function(attribute, rule) {\n                var lowerRule = snakeCase(rule);\n                // There are three different types of size validations. The\n                // attribute may be either a number, file, or string so we\n                // will check a few things to know which type of value it is\n                // and return the correct line for that type.\n                var type = this.getAttributeType(attribute);\n\n                var key = [lowerRule, '.', type].join('');\n\n                return ValidationTranslator.trans(key);\n            };\n\n            /**\n             * Replace all error message place-holders with actual values.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.doReplacements = function(message, attribute, rule, parameters) {\n                message = replace(message, {\n                    attribute: attribute\n                });\n\n                if (this['replace' + rule] !== undefined) {\n                    message = this['replace' + rule](message, attribute, rule, parameters);\n                }\n\n                return message;\n            };\n\n            /**\n             * Get the value of a given attribute.\n             *\n             * @param   {string} attribute\n             *\n             * @returns {*}\n             */\n            Validation.prototype.getValue = function(attribute) {\n                return this.data[attribute];\n            };\n\n            /**\n             * Determine if any of the given attributes fail the required test.\n             *\n             * @param   {array} attributes\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.anyFailingRequired = function(attributes) {\n                for (var key in attributes) {\n                    if (!this.validateRequired(attributes[key], this.getValue(attributes[key]))) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            /**\n             * Determine if all of the given attributes fail the required test.\n             *\n             * @param   {Array} attributes\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.allFailingRequired = function(attributes) {\n                for (var key in attributes) {\n                    if (this.validateRequired(attributes[key], this.getValue(attributes[key]))) {\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute was \"accepted\".\n             *\n             * This validation rule implies the attribute is \"required\".\n             *\n             * @param   {string}  attribute\n             * @param   {*}       value\n             *\n             * @return {boolean}\n             */\n            Validation.prototype.validateAccepted = function(attribute, value) {\n                var acceptable = ['yes', 'on', '1', 1, true, 'true'];\n\n                return (this.validateRequired(attribute, value) && acceptable.indexOf(value) !== -1);\n            };\n\n            /**\n             * Validate that a required attribute exists.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @return {boolean}\n             */\n            Validation.prototype.validateRequired = function(attribute, value) {\n                if (value === null || value === undefined) {\n                    return false\n                } else if (typeof value === 'string') {\n                    if (value.trim() === '') {\n                        return false;\n                    }\n                } else if (value instanceof Array) {\n                    if (value.length < 1) {\n                        return false\n                    }\n                } else if (value instanceof Object && !(value instanceof Date)) {\n                    if (Object.getOwnPropertyNames(value).length === 0) {\n                        return false;\n                    }\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when other attribute has\n             * certain value.\n             *\n             * @param {string} attribute\n             * @param {*}      value\n             * @param {Array}  parameters\n             *\n             * @return {boolean}\n             */\n            Validation.prototype.validateRequiredIf = function(attribute, value, parameters) {\n                if (this.getValue(parameters[0]) == parameters[1]) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when any other attribute\n             * exists.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {Array}  parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWith = function(attribute, value, parameters) {\n                if (!this.allFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when all other attributes\n             * exists.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {*}      parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWithAll = function(attribute, value, parameters) {\n                if (!this.anyFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when another attribute does\n             * not.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {*}      parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWithout = function(attribute, value, parameters) {\n                if (this.anyFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when all other attributes do\n             * not.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {*}      parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateRequiredWithoutAll = function(attribute, value, parameters) {\n                if (this.allFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                }\n\n                return true;\n            };\n\n            /**\n             * Validate an attribute is contained within a list of values.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {Array}  parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateIn = function(attribute, value, parameters) {\n                return parameters.indexOf('' + value) !== -1;\n            };\n\n            /**\n             * Validate an attribute is not contained within a list of values.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             * @param   {Array}  parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateNotIn = function(attribute, value, parameters) {\n                return !this.validateIn(attribute, value, parameters);\n            };\n\n            /**\n             * Validate that an attribute is an integer.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateInteger = function(attribute, value) {\n                return !isNaN(value) && value === (value | 0);\n            };\n\n            /**\n             * Validate that an attribute is numeric.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateNumeric = function(attribute, value) {\n                return !isNaN(value);\n            };\n\n            /**\n             * Validate the size of an attribute is between a set of values.\n             *\n             * @param   {string}              attribute\n             * @param   {string|number|Array} value\n             * @param   {Array}               parameters\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.validateBetween = function(attribute, value, parameters) {\n                this.requireParameterCount(2, parameters, 'between');\n\n                var size = this.getSize(attribute, value);\n\n                return size >= parameters[0] && size <= parameters[1];\n            };\n\n            /**\n             * Require a certain number of parameters to be present.\n             *\n             * @param   {Integer} count\n             * @param   {Array}   parameters\n             * @param   {string}  rule\n             *\n             * @returns {undefined}\n             *\n             * @throws {Error}\n             */\n            Validation.prototype.requireParameterCount = function(count, parameters, rule) {\n                if (parameters.length < count) {\n                    throw new Error(\"Validation rule \" + rule + \" requires at least \" + count + \" parameters.\");\n                }\n            };\n\n            /**\n             * Get the size of an attribute.\n             *\n             * @param   {string}              attribute\n             * @param   {string|number|Array} value\n             *\n             * @returns {number}\n             */\n            Validation.prototype.getSize = function(attribute, value) {\n                var hasNumeric = this.hasRule(attribute, this.numericRules);\n\n                // This method will determine if the attribute is a number,\n                // string, or array and return the proper size accordingly. If\n                // it is a number, then number itself is the size. If it is an\n                // array, we take length, and for a string the entire length\n                // of the string will be considered the attribute size.\n                if (!isNaN(value) && hasNumeric) {\n                    return this.data[attribute];\n                } else if (Array.isArray(value)) {\n                    return value.length;\n                }\n\n                return this.getStringSize(value);\n            };\n\n            /**\n             * Get the size of a string.\n             *\n             * @param   {string} value\n             *\n             * @returns {number}\n             */\n            Validation.prototype.getStringSize = function(value) {\n                if (value) {\n                    return ('' + value).trim().length;\n                }\n\n                return 0;\n            };\n\n            /**\n             * Determine if the given attribute has a rule in the given set.\n             *\n             * @param   {string}        attribute\n             * @param   {string|Object} rules\n             *\n             * @returns {boolean}\n             */\n            Validation.prototype.hasRule = function(attribute, rules) {\n                return !!this.getRule(attribute, rules);\n            };\n\n            /**\n             * Get a rule and its parameters for a given attribute.\n             *\n             * @param   {string}        attribute\n             * @param   {string|Object} rules\n             *\n             * @returns {Object|undefined}\n             */\n            Validation.prototype.getRule = function(attribute, rules) {\n                if (!this.rules[attribute]) {\n                    return;\n                }\n\n                for (var rule in this.rules) {\n                    var parsed = this.parseRule(this.rules[rule]);\n\n                    if (rules.indexOf(parsed.rule) !== -1) {\n                        return parsed;\n                    }\n                }\n            };\n\n            /**\n             * Get the displayable name of the attribute.\n             *\n             * @param   {string} attribute\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getAttribute = function(attribute) {\n                // The developer may dynamically specify the array of custom\n                // attributes on this Validation instance. If the attribute\n                // exists in this array it takes precedence over all other\n                // ways we can pull attributes.\n                if (this.customAttributes[attribute]) {\n                    return this.customAttributes[attribute];\n                }\n\n                var key = 'attributes.' + attribute;\n                // We allow for the developer to specify language messages for\n                // each of the attributes allowing for more displayable\n                // counterparts of each of the attributes. This provides the\n                // ability for simple formats.\n\n                var message = ValidationTranslator.trans(key);\n\n                if (message !== key) {\n                    return message;\n                }\n\n                // If no language message has been specified for the attribute\n                // all of the underscores are removed from the attribute name\n                // and that will be used as default versions of the\n                // attribute`s displayable names.\n                return snakeCase(attribute).replace(/_/g, ' ');\n            };\n\n            /**\n             * Get the data type of the given attribute.\n             *\n             * @param   {string} attribute\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getAttributeType = function(attribute) {\n                if (this.hasRule(attribute, this.numericRules)) {\n                    return 'numeric';\n                } else if (this.hasRule(attribute, 'Array')) {\n                    return 'array';\n                }\n\n                return 'string';\n            };\n\n            /**\n             * Transform an array of attributes to their displayable form.\n             *\n             * @param   {Array} values\n             *\n             * @returns {Array}\n             */\n            Validation.prototype.getAttributeList = function(values) {\n                var attributes = [];\n\n                // For each attribute in the list we will simply get its\n                // displayable form as this is convenient when replacing lists\n                // of parameters like some of the replacement functions do\n                // when formatting out the validation message.\n                for (var i = 0; i < values.length; i++) {\n                    attributes.push(this.getAttribute(values[i]));\n                }\n\n                return attributes;\n            };\n\n            /**\n             * Get the displayable name of the value.\n             *\n             * @param   {string} attribute\n             * @param   {*}      value\n             *\n             * @returns {string}\n             */\n            Validation.prototype.getDisplayableValue = function(attribute, value) {\n                if (this.customValues[attribute] && this.customValues[attribute][value]) {\n                    return this.customValues[attribute][value];\n                }\n\n                var key = 'values.' + attribute + '.' + value;\n\n                var message = ValidationTranslator.trans(key);\n\n                if (message !== key) {\n                    return message;\n                }\n\n                return value;\n            };\n\n            /**\n             * Replace all place-holders for the between rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceBetween = function(message, attribute, rule, parameters) {\n                return message.replace(':min', parameters[0]).replace(':max', parameters[1]);\n            };\n\n            /**\n             * Replace all place-holders for the size rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceSize = function(message, attribute, rule, parameters) {\n                return message.replace(':size', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the min rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceMin = function(message, attribute, rule, parameters) {\n                return message.replace(':min', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the max rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceMax = function(message, attribute, rule, parameters) {\n                return message.replace(':max', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the in rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceIn = function(message, attribute, rule, parameters) {\n                for (var i = 0; i < parameters.length; i++) {\n                    parameters[i] = this.getDisplayableValue(attribute, parameters[i]);\n                }\n\n                return message.replace(':values', parameters.join(', '));\n            };\n\n            /**\n             * Replace all place-holders for the not_in rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceNotIn = function(message, attribute, rule, parameters) {\n                return this.replaceIn(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_if rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredIf = function(message, attribute, rule, parameters) {\n                parameters[1] = this.getDisplayableValue(parameters[0], this.getValue(parameters[0]));\n                parameters[0] = this.getAttribute(parameters[0]);\n\n                return replace(message, {other: parameters[0], value: parameters[1]});\n            };\n\n            /**\n             * Replace all place-holders for the required_with rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWith = function(message, attribute, rule, parameters) {\n                parameters = this.getAttributeList(parameters);\n                return message.replace(':values', parameters.join(' / '));\n            };\n\n            /**\n             * Replace all place-holders for the required_with_all rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWithAll = function(message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_without rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWithout = function(message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_without_all rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceRequiredWithoutAll = function(message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the same rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceSame = function(message, attribute, rule, parameters) {\n                return message.replace(':other', this.getAttribute(parameters[0]));\n            };\n\n            /**\n             * Replace all place-holders for the different rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceDifferent = function(message, attribute, rule, parameters) {\n                return this.replaceSame(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the date_format rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceDateFormat = function(message, attribute, rule, parameters) {\n                return message.replace(':format', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the before rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceBefore = function(message, attribute, rule, parameters) {\n                if (!Date.parse(parameters[0])) {\n                    return message.replace(':date', this.getAttribute(parameters[0]));\n                }\n                return message.replace(':date', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the after rule.\n             *\n             * @param   {string} message\n             * @param   {string} attribute\n             * @param   {string} rule\n             * @param   {Array}  parameters\n             *\n             * @returns {string}\n             */\n            Validation.prototype.replaceAfter = function(message, attribute, rule, parameters) {\n                return this.replaceBefore(message, attribute, rule, parameters);\n            };\n        }\n\n        /**\n         * Helpers goes next\n         */\n\n        /**\n         * Convert each word`s first letter to upper case.\n         *\n         * @param {String} str\n         *\n         * @return {String}\n         */\n        function upperCaseWords(str) {\n            return (str + '').replace(/^([a-z])|\\s+([a-z])/g, function($1) {\n                return $1.toUpperCase();\n            });\n        }\n\n        /**\n         * Convert text into studly case.\n         *\n         * @param {String} str\n         *\n         * @return {String}\n         */\n        function studlyCase(str) {\n            str = upperCaseWords((str + '').replace(/[-_]/g, ' '));\n            return str.replace(/[\\s]/g, '');\n        }\n\n        /**\n         * Convert text into snake case.\n         *\n         * @param {String} str\n         *\n         * @return {String}\n         */\n        function snakeCase(str) {\n            return (str + '').replace(/(.)([A-Z])/g, '$1_$2').toLowerCase();\n        }\n\n        /**\n         * Replace placeholders with object keys\n         *\n         * @example\n         * // returns 'Dear Andrew'\n         * var str = \":greet :name\"\n         * var greet = {greet: 'Dear', name: 'Andrew'};\n         * replace(str, greet);\n         *\n         * @param {String} str  String containing placeholders\n         * @param {Object} data Object with corresponding keys\n         *\n         * @return {String} Final string with replaced placeholders\n         */\n        function replace(str, data) {\n            return (str + '').replace(/:([A-z]*)/g,\n                function(a, b) {\n                    var r = data[b];\n                    return typeof r === 'string' || typeof r === 'number' ? r : a;\n                }\n            );\n        }\n    }\n\n})();\n","(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.validation-translator')\n        .value('validationTranslatorLang', {\n            locale: 'en',\n            fallback: 'en'\n        })\n        .factory('ValidationTranslator', ValidationTranslator);\n\n    /*@ngInject*/\n    function ValidationTranslator(validationTranslatorLang, validationTranslatorConfig) {\n        return {\n            trans: trans\n        };\n\n        function trans(key) {\n            var message = null;\n\n            // Here we will get the locale that should be used for the\n            // language. If one was not passed, we will use the default\n            // locale. Then, we can get the  message and return.\n            var locales = [\n                validationTranslatorLang.locale,\n                validationTranslatorLang.fallback\n            ];\n\n            for (var i = 0; i < locales.length; i++) {\n                message = getMessage(locales[i], key);\n\n                if (message) break;\n            }\n\n            // If the message doesn't exist, we will return back the key\n            // which was requested as that will be quick to spot in the UI\n            // if language keys are wrong or missing from the translator's\n            // language config. Otherwise we can return the message.\n            if (!message) return key;\n\n            return message;\n        }\n\n        function getMessage(locale, key) {\n            var message;\n\n            var localeData = validationTranslatorConfig[locale];\n\n            if (localeData) {\n                var data = localeData;\n                var keys = key.split('.');\n\n                for (var i = 0; i < keys.length; i++) {\n                    if (data[keys[i]]) {\n                        data = data[keys[i]];\n                    } else {\n                        return;\n                    }\n                }\n\n                message = data;\n            }\n\n            return message;\n        }\n    }\n\n})();\n","(function() {\n    'use strict';\n\n    angular\n        .module('ngValidator.validation-translator')\n        .value('validationTranslatorConfig', {\n            \"en\": {\n                \"accepted\": \"The :attribute must be accepted.\",\n                \"between\": {\n                    \"numeric\": \"The :attribute must be between :min and :max.\",\n                    \"string\": \"The :attribute must be between :min and :max characters.\",\n                    \"array\": \"The :attribute must have between :min and :max items.\"\n                },\n                \"in\": \"The selected :attribute is invalid.\",\n                \"integer\": \"The :attribute must be an integer.\",\n                \"max\": {\n                    \"numeric\": \"The :attribute may not be greater than :max.\",\n                    \"string\": \"The :attribute may not be greater than :max characters.\",\n                    \"array\": \"The :attribute may not have more than :max items.\"\n                },\n                \"min\": {\n                    \"numeric\": \"The :attribute must be at least :min.\",\n                    \"string\": \"The :attribute must be at least :min characters.\",\n                    \"array\": \"The :attribute must have at least :min items.\"\n                },\n                \"not_in\": \"The selected :attribute is invalid.\",\n                \"numeric\": \"The :attribute must be a number.\",\n                \"regex\": \"The :attribute format is invalid.\",\n                \"required\": \"The :attribute field is required.\",\n                \"required_if\": \"The :attribute field is required when :other is :value.\",\n                \"required_with\": \"The :attribute field is required when :values is present.\",\n                \"required_with_all\": \"The :attribute field is required when :values is present.\",\n                \"required_without\": \"The :attribute field is required when :values is not present.\",\n                \"required_without_all\": \"The :attribute field is required when none of :values are present.\",\n\n                // Developers can set custom validation messages on some\n                // attributes validation rules\n                \"custom\": {\n                    \"attribute-name\": {\n                        \"rule-name\": \"custom-message\"\n                    }\n                },\n\n                // Developers can set displayable value for some attributes\n                \"attributes\": {\n                    \"email\": \"Email address\"\n                },\n\n                // As an example just set displayable value for colors attribute\n                // and its values\n                \"values\": {\n                    \"colors\": {\n                        \"F00\": \"Red\",\n                        \"0F0\": \"Green\",\n                        \"00F\": \"Blue\"\n                    }\n                }\n            }\n        });\n})();"],"sourceRoot":"/source/"}